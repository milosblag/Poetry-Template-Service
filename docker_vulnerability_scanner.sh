#!/bin/bash
set -e

# Default values
IMAGE_NAME="hello-world-api:latest"
SEVERITY="HIGH,CRITICAL"
OUTPUT_FORMAT="table"
OUTPUT_FILE=""
TIMEOUT="10m"
SCAN_PYTHON=true
SCAN_OS=true
GENERATE_REPORT=false
DOCKER_SOCKET="/var/run/docker.sock"

# Display help message
function show_help {
    echo "Docker Image Security Scanner"
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --image NAME[:TAG]    Docker image to scan (default: $IMAGE_NAME)"
    echo "  --severity LEVEL      Comma-separated list of severity levels to scan for (default: $SEVERITY)"
    echo "                        Possible values: UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL"
    echo "  --format FORMAT       Output format (default: $OUTPUT_FORMAT)"
    echo "                        Possible values: table, json, sarif, cyclonedx, github"
    echo "  --output FILE         Write results to file instead of stdout"
    echo "  --timeout DURATION    Timeout duration (default: $TIMEOUT)"
    echo "  --socket PATH         Docker socket path (default: auto-detect)"
    echo "  --skip-python         Skip scanning Python packages"
    echo "  --skip-os             Skip scanning OS packages"
    echo "  --report              Generate a security report in Markdown format"
    echo "  --help                Show this help message"
    echo ""
    echo "Example:"
    echo "  $0 --image myapp:1.0.0 --severity HIGH,CRITICAL --format json --output scan-results.json"
    exit 0
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        --image)
            IMAGE_NAME="$2"
            shift 2
            ;;
        --severity)
            SEVERITY="$2"
            shift 2
            ;;
        --format)
            OUTPUT_FORMAT="$2"
            shift 2
            ;;
        --output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --socket)
            DOCKER_SOCKET="$2"
            shift 2
            ;;
        --skip-python)
            SCAN_PYTHON=false
            shift
            ;;
        --skip-os)
            SCAN_OS=false
            shift
            ;;
        --report)
            GENERATE_REPORT=true
            shift
            ;;
        --help)
            show_help
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            ;;
    esac
done

# Check if Docker is available
if ! command -v docker &> /dev/null; then
    echo "Error: Docker is not installed or not in PATH"
    exit 1
fi

# Auto-detect Docker socket if not specified
if [ "$DOCKER_SOCKET" = "/var/run/docker.sock" ]; then
    echo "🔍 Auto-detecting Docker socket location..."
    
    # Check if default socket exists
    if [ -S /var/run/docker.sock ]; then
        echo "✅ Found Docker socket at default location: /var/run/docker.sock"
        DOCKER_SOCKET="/var/run/docker.sock"
    # Check macOS alternative location
    elif [ -S "$HOME/.docker/run/docker.sock" ]; then
        echo "✅ Found Docker socket at macOS location: $HOME/.docker/run/docker.sock"
        DOCKER_SOCKET="$HOME/.docker/run/docker.sock"
        # Set DOCKER_HOST for macOS
        export DOCKER_HOST="unix://$HOME/.docker/run/docker.sock"
        echo "🔍 Setting DOCKER_HOST=$DOCKER_HOST"
    # Check Windows WSL2 alternative location
    elif [ -S "/mnt/wsl/docker-desktop/docker.sock" ]; then
        echo "✅ Found Docker socket at WSL2 location: /mnt/wsl/docker-desktop/docker.sock"
        DOCKER_SOCKET="/mnt/wsl/docker-desktop/docker.sock"
        # Set DOCKER_HOST for WSL2
        export DOCKER_HOST="unix:///mnt/wsl/docker-desktop/docker.sock"
        echo "🔍 Setting DOCKER_HOST=$DOCKER_HOST"
    else
        # Check if Docker is available through TCP
        if docker info &>/dev/null; then
            echo "⚠️ No Docker socket found, but Docker connection successful (possibly TCP)"
            echo "⚠️ Will attempt to use Docker directly instead of mounting socket"
            DOCKER_SOCKET=""
        else
            echo "❌ Could not find Docker socket at any standard location"
            echo "Please specify the socket path manually with --socket option"
            echo "Alternatively, set the DOCKER_HOST environment variable"
            exit 1
        fi
    fi
fi

# Check Docker connectivity
echo "🔍 Verifying Docker connectivity..."
if ! docker info &>/dev/null; then
    echo "❌ Cannot connect to Docker daemon"
    echo "❌ Docker daemon connection failed"
    echo "Please run the diagnostic tool: ./docker_connectivity_check.sh"
    exit 1
fi

# Check if the image exists
echo "🔍 Checking for Docker image: $IMAGE_NAME"
if ! docker image inspect "$IMAGE_NAME" &> /dev/null; then
    echo "⚠️ Image not found: $IMAGE_NAME"
    echo "Would you like to build or pull this image? (b)uild/(p)ull/(s)kip"
    read -r response
    case "$response" in
        [bB])
            if [ -f "Dockerfile" ]; then
                echo "🏗️ Building image: $IMAGE_NAME"
                docker build -t "$IMAGE_NAME" .
            else
                echo "❌ Dockerfile not found. Cannot build image."
                exit 1
            fi
            ;;
        [pP])
            echo "📥 Pulling image: $IMAGE_NAME"
            docker pull "$IMAGE_NAME" || {
                echo "❌ Failed to pull image: $IMAGE_NAME"
                exit 1
            }
            ;;
        *)
            echo "⚠️ Proceeding without image. Scan may fail."
            ;;
    esac
fi

# Prepare scan command - Use local trivy if available, otherwise use container
if command -v trivy &> /dev/null; then
    echo "✅ Using locally installed Trivy"
    SCAN_CMD="trivy image"
else
    echo "⚠️ Trivy not found locally, using Docker container"
    # Export the current DOCKER_HOST to the container
    if [ -n "$DOCKER_HOST" ]; then
        SCAN_CMD="docker run --rm -e DOCKER_HOST=\"$DOCKER_HOST\""
    else
        # Only mount socket if it's the standard location
        if [ "$DOCKER_SOCKET" = "/var/run/docker.sock" ]; then
            SCAN_CMD="docker run --rm -v /var/run/docker.sock:/var/run/docker.sock"
        else
            SCAN_CMD="docker run --rm"
        fi
    fi
    SCAN_CMD="$SCAN_CMD aquasec/trivy image"
fi

# Add options
if [ "$SCAN_PYTHON" = false ]; then
    SCAN_CMD="$SCAN_CMD --skip-files-with-python"
fi

if [ "$SCAN_OS" = false ]; then
    SCAN_CMD="$SCAN_CMD --skip-os-packages"
fi

SCAN_CMD="$SCAN_CMD --severity $SEVERITY --timeout $TIMEOUT"

if [ -n "$OUTPUT_FILE" ]; then
    # Handle output file 
    if command -v trivy &> /dev/null; then
        # With local trivy, direct output
        mkdir -p "$(dirname "$OUTPUT_FILE")"
        SCAN_CMD="$SCAN_CMD --format $OUTPUT_FORMAT --output $OUTPUT_FILE"
    else
        # With container trivy, need to mount directory
        OUTPUT_DIR=$(dirname "$OUTPUT_FILE")
        OUTPUT_FILE_NAME=$(basename "$OUTPUT_FILE")
        mkdir -p "$OUTPUT_DIR"
        SCAN_CMD="$SCAN_CMD -v $(pwd)/$OUTPUT_DIR:/output --format $OUTPUT_FORMAT --output /output/$OUTPUT_FILE_NAME"
    fi
else
    SCAN_CMD="$SCAN_CMD --format $OUTPUT_FORMAT"
fi

# Add image name
SCAN_CMD="$SCAN_CMD $IMAGE_NAME"

# Print scan information
echo "==============================================="
echo "🔍 Docker Image Security Scanner"
echo "==============================================="
echo "Image: $IMAGE_NAME"
echo "Scanning for: $SEVERITY vulnerabilities"
echo "Timeout: $TIMEOUT"
echo "Format: $OUTPUT_FORMAT"
if [ -n "$OUTPUT_FILE" ]; then
    echo "Output: $OUTPUT_FILE"
fi
if [ -n "$DOCKER_HOST" ]; then
    echo "Docker Host: $DOCKER_HOST"
fi
echo "==============================================="
echo "Starting vulnerability scan..."
echo "Running: $SCAN_CMD"

# Run the scan
SCAN_EXIT_CODE=0
if ! eval "$SCAN_CMD"; then
    SCAN_EXIT_CODE=$?
    echo "⚠️ Scan completed with exit code $SCAN_EXIT_CODE"
else
    echo "✅ Scan completed successfully"
fi

# Generate security report if requested
if [ "$GENERATE_REPORT" = true ]; then
    REPORT_FILE="security-report-$(date +%Y%m%d).md"
    
    echo "# Security Report for $IMAGE_NAME" > "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "## Scan Information" >> "$REPORT_FILE"
    echo "- **Date**: $(date)" >> "$REPORT_FILE"
    echo "- **Image**: $IMAGE_NAME" >> "$REPORT_FILE"
    echo "- **Severity Levels**: $SEVERITY" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    
    echo "## Vulnerability Summary" >> "$REPORT_FILE"
    
    if [ -n "$OUTPUT_FILE" ] && [ "$OUTPUT_FORMAT" = "json" ]; then
        # Need to install jq for JSON parsing
        if command -v jq &> /dev/null; then
            # Extract summary from JSON output - handle null values safely
            VULN_COUNT=$(jq '.Results | map(.Vulnerabilities | length // 0) | add // 0' "$OUTPUT_FILE")
            CRITICAL_COUNT=$(jq '.Results | map(.Vulnerabilities // [] | map(select(.Severity == "CRITICAL")) | length) | add // 0' "$OUTPUT_FILE")
            HIGH_COUNT=$(jq '.Results | map(.Vulnerabilities // [] | map(select(.Severity == "HIGH")) | length) | add // 0' "$OUTPUT_FILE")
            MEDIUM_COUNT=$(jq '.Results | map(.Vulnerabilities // [] | map(select(.Severity == "MEDIUM")) | length) | add // 0' "$OUTPUT_FILE")
            LOW_COUNT=$(jq '.Results | map(.Vulnerabilities // [] | map(select(.Severity == "LOW")) | length) | add // 0' "$OUTPUT_FILE")
            
            echo "- **Total vulnerabilities**: $VULN_COUNT" >> "$REPORT_FILE"
            echo "- **Critical**: $CRITICAL_COUNT" >> "$REPORT_FILE"
            echo "- **High**: $HIGH_COUNT" >> "$REPORT_FILE"
            echo "- **Medium**: $MEDIUM_COUNT" >> "$REPORT_FILE"
            echo "- **Low**: $LOW_COUNT" >> "$REPORT_FILE"
            
            # Add additional details if vulnerabilities were found
            if [ "$VULN_COUNT" -gt 0 ]; then
                echo "" >> "$REPORT_FILE"
                echo "## Vulnerability Details" >> "$REPORT_FILE"
                echo "" >> "$REPORT_FILE"
                
                # Extract details of each vulnerability
                jq -r '
                    .Results[] | 
                    select(.Vulnerabilities != null) | 
                    .Vulnerabilities[] | 
                    select(.Severity == "CRITICAL" or .Severity == "HIGH") | 
                    "### " + .VulnerabilityID + "\n\n" +
                    "- **Severity**: " + .Severity + "\n" +
                    "- **Package**: " + .PkgName + " (" + .InstalledVersion + ")\n" +
                    "- **Fixed Version**: " + (.FixedVersion // "Not available") + "\n" +
                    "- **Description**: " + (.Description // "No description available") + "\n" +
                    "- **References**: " + (.References[0] // "None available") + "\n"
                ' "$OUTPUT_FILE" >> "$REPORT_FILE" 2>/dev/null || echo "⚠️ Could not extract detailed vulnerability information" >> "$REPORT_FILE"
            fi
        else
            echo "⚠️ jq is not installed. Cannot parse JSON results for report." >> "$REPORT_FILE"
            echo "Please install jq for better reporting: https://stedolan.github.io/jq/download/" >> "$REPORT_FILE"
        fi
    else
        echo "For detailed vulnerability information, please run the scan with JSON output format." >> "$REPORT_FILE"
    fi
    
    echo "" >> "$REPORT_FILE"
    echo "## Recommendations" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "1. Update vulnerable packages to their latest versions" >> "$REPORT_FILE"
    echo "2. Consider using a more secure base image" >> "$REPORT_FILE"
    echo "3. Implement least privilege principles" >> "$REPORT_FILE"
    echo "4. Use multi-stage builds to reduce attack surface" >> "$REPORT_FILE"
    echo "5. Run containers as non-root users" >> "$REPORT_FILE"
    echo "6. Regularly scan images for vulnerabilities" >> "$REPORT_FILE"
    
    echo "Security report generated: $REPORT_FILE"
fi

# Finish with appropriate exit code
exit $SCAN_EXIT_CODE 